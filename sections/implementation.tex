\section{Implementation}\label{sec:implementation}
With the theory explained, we can now explore our implementation, which aims to
be as true to reality as possible. We will start by laying the foundation of 
the most pivotal data structures, followed by a walk-through of the 
implementation of each phase of the game. 

\subsection{Foundational Data Structures}\label{sec:foundationalDataStructures}
This section should contain an explanation of the following: 
\begin{enumerate}
	\item The world object. (and what is tworlds?)
	\item The player object. 
	\item How the player object relates to me.functions and self.functions.
	\item The game object. 
\end{enumerate} 
\textit{For now, i have copied the contents of knowledge of agents and updating 
of knowledge into this section. Remove and change as needed. Remove 
subsubsections though.}

\subsubsection{The Knowledge of Agents}\label{sec:TheKnowledgeOfAgents}
The knowledge and logical propositions of agents has been chosen to be
represented with a truth-table approach. Every agent has their own list of
possible-worlds, in which every single combination of agents and roles. This
means, that the more agents and roles there are, the longer this list becomes.
The following equation shows the space complexity of the list given agent count
$P$ and the number of agents with role $R$.
\begin{equation}
	W: P,R \in  \mathbb{N} \mapsto \frac{P!}{R!(P-R)!}\
\end{equation}

For each subsequent role, $R_1, R_2...$ that is added, the complexity expands 
with:
\begin{equation}
	\begin{gathered}
		W: P, R_1, R_2\in  \mathbb{N} \mapsto \\
		\frac{P!\cdot(P-R_1)!}{R_1!\cdot(P-R_1)!\cdot
			R_2!\cdot(P-R_1-R_2)}\
		\footnote{If the number of agents equals the
			number of roles, then the formula collapses into P!.}
	\end{gathered}
\end{equation}
Each agent excludes possible-worlds that are not in
accordance with the role that they have been given.\\
For example: agent, \textit{a}, if given the role of sheriff, will exclude all
possible-worlds where their role is not sheriff, while another agent \textit{b} 
may
keep some of those possible-worlds, since they do not know the role of 
\textit{a}.\\
Furthermore, each possible-world also contains data on who have made what 
claims, and
whether that claim is true or false in this given possible-world. This is 
represented
by an array for each possible-world, which keeps track of the lies of agents. 
Going forward, these lies will be known as
\textit{marks}. If a world has many
marks, it implies that many agents have lied if this is the true world. It is
also important to remember, that we keep track of who contributed to each mark
in a given world. This will be explained further in the following sections.

\subsection{Updating Knowledge}\label{sec:UpdatingKnowledge}
When a new fact is revealed, such as when an agent dies and their role is
revealed, all agents will immediately exclude all possible-worlds in which the
dead agent is anything other than their revealed role. This is essentially the
model update defined in \cref{eq:5}. An agent dying is the way that most roles
learn new facts.\\ Furthermore, depending on the role that died, all agents
update the marks that the dead agent contributed to. For example:\\ A sheriff
has a nightly action which allows them to gain more information than regular
villagers. Therefore, the marks that a sheriff has contributed to, should be
weighed more heavily than those of other roles. To emulate this other agents
add an additional mark, to any marks that were contributed to by the sheriff,
to further denote the importance of their opinions. \\ Conversely, should the
dead agent be revealed to be a member of the mafia, all agents will detract a
mark from the marks that the dead agent contributed to. Due to that the mafia
member may have tried to deceive the other agents

\subsection{Beginning of the Game}\label{sec:beginningOfTheGame}
With the foundational data structures explained, we can begin the game, which 
is done in accordance with the pseudocode in algorithm \ref{alg:StartGame}.
\begin{algorithm}[H]
	\caption{StartGame}
	\begin{algorithmic}[1]
		\Function{StartGame}{}
		\State loadGameConfiguration()
		\State generateWorlds()
		
		\While{!gameFinished}
		\State dayPhase()
		\State nightPhase()
		\State checkFinished()
		\EndWhile
		\EndFunction
	\end{algorithmic}\label{alg:StartGame}
\end{algorithm} 
\setcounter{algorithmcaption}{0}
\captionof{algorithmcaption}{Pseudocode for starting and running the 
game.}
The game begins by loading the role-configuration for that specific game, and 
then generating the worlds for all players. It then goes through the day- and 
night phases, followed by checking if either team has won. It does this in a 
loop until either team has won. 

\subsection{Day Phase}\label{sec:dayPhase}
The day phase is split into two sub-phases: communication and voting. These 
phases are performed in order, and controlled by algorithm \ref{alg:dayPhase}.
\begin{algorithm}[H]
	\caption{Day phase}
	\begin{algorithmic}[1]
		\Function{dayPhase}{}
		\ForAll{p $in$ game.Ps}
		\State p.communicate()
		\EndFor
		\ForAll{p $in$ game.Ps}
		\State votes $\gets$ votes + voting()
		\EndFor
		
		\State killMostVoted(votes)
		\EndFunction
	\end{algorithmic}\label{alg:dayPhase}
\end{algorithm}
\setcounter{algorithmcaption}{1}
\captionof{algorithmcaption}{The order of sub-phases within the day phase.}
First all players communicate, then they all vote.

\subsubsection{Communication}\label{sec:communication}
The communication sub-phase is where agents share information with each other 
based on the marks in their individual world-views. Communicative actions are 
the main way to contribute to marks in a given possible-world. The way that a 
given agent chooses who to target with their communicative action is chosen in 
accordance with algorithm \ref{alg:GetHighInfoGainP}. 
\begin{algorithm}[H]
	\caption{GetHighInfoGainP(me, tWorlds)}
	\begin{algorithmic}
		\If{nonAccused.Count $>$ 0 OR Game.Round = 0}
		\State $(p, wID)$ $\gets$ GetNonAccused(me)
		\If{wID != -1}
		\State \Return (p, wID)
		\EndIf
		\EndIf
		
		\State (p, wID) $\gets$ GetMostContradictory(tWorlds, me)
		\If{wID != -1}
		\State \Return (p, wID)
		\EndIf
		
		\State w $\gets$ random world from me.PossWorlds
		\State p $\gets$ random player from w.PossPlayers
		\State \Return (p, index of w in me.PossWorlds)
	\end{algorithmic}\label{alg:GetHighInfoGainP}
\end{algorithm}
\setcounter{algorithmcaption}{2}
\captionof{algorithmcaption}{Get the highest information gain agent returns an 
agent based on different factors.
	At first, it prioritizes non accused agents as shown in 
	\cref{alg:GetNonAccused}.
	Then find the most contradictory information as shown in 
	\cref{alg:GetMostContradictory}.
	Otherwise, choose a random world and a random agent within.}
The output of this algorithm is the target that the calling agent knows the 
least about, meaning they have the most to gain when choosing that target. The 
initial check within the algorithm relates to algorithm \ref{alg:GetNonAccused}.
\begin{algorithm}[H]
	\caption{GetNonAccused(me)}
	\begin{algorithmic}
		\If{nonAccused.Count = 0 AND Game.Round = 0}
		\State nonAccused $\gets$ all players in me.PossWorlds[0]
		\EndIf
		
		\ForAll{accusation in me.nonAccu}
		\State me.nonAccu.Remove(accusation.Acusse)
		\EndFor
		
		\State me.nonAccu.Remove(me)
		
		\If{nonAccused.Count != 0}
		\State \Return nonAccused[randomI]
		\EndIf
		
		\State \Return (null, -1)
	\end{algorithmic}\label{alg:GetNonAccused}
\end{algorithm}
\setcounter{algorithmcaption}{3}
\captionof{algorithmcaption}{First round we append all agents to the non 
accused list and remove the agent itself from the list
	Then returning a random agent if the list is non-empty.}
This algorithm initialises a list of all other agents for each agent at the 
start of the first communication phase. Whenever an agent targets another agent 
with a communicative action they remove the target agent from their individual 
list. When an agent has targeted all other agents with one communicative action 
they will have gained some knowledge of all agent, meaning they now have some 
data that they may use to determine the new best target for their communicative 
actions. This is done in the next step of algorithm \ref{alg:GetHighInfoGainP}, 
by invoking algorithm \ref{alg:GetMostContradictory}.  
\begin{algorithm}[H]
	\caption{GetMostContradictory(tWorlds, me)}
	\begin{algorithmic}
		\State roleCounts $\gets$ getRoleCounts(tWorlds)
		
		\ForAll{w in tWorlds}
		\ForAll{p in w.PossPlayers where p != me AND p is alive}
		\State highest $\gets$ roleCounts[p].Max()
		\State secHighest $\gets$ roleCounts[p].SecondMax()
		
		\State contraScore $\gets$ secHighest / highest
		\If{contraScore $>$ maxScore}
		\State mostContradictory $\gets$ p
		\State maxScore $\gets$ contraScore
		\State wID $\gets$ index of w
		\EndIf
		\EndFor
		\EndFor
		\State \Return (mostContradictory, wID)
	\end{algorithmic}\label{alg:GetMostContradictory}
\end{algorithm}
\setcounter{algorithmcaption}{4}
\captionof{algorithmcaption}{Starting by storing a list of role counts for 
agents in the top 1\% of worlds.
	Iterating over the top 1\% of worlds and for each possible agent find their 
	highest and second-highest role counts.
	Calculating a contradction score based on the 2 top role counts and 
	checking if it's the highest contradiction score found.
	Returning the maxScore once all possible agents have been checked.
}
This algorithm outputs the agent which is the most suspicious due to being 
suspected of being the most different roles in the top 1\% of possible-worlds.\\
This whole process is simply described in the following high-level algorithm 
\ref{alg:communicate} for how one agent handles their turn in the communication 
sub-phase. 
\begin{algorithm}[H]
	\caption{Communication}
	\begin{algorithmic}[1]
		\Function{communicate}{}
		\State world $\gets$ getMostPlausibleWorld()
		\State action $\gets$ self.getAction(world)
		
		\If{action is inquire or accuse}
		\State p $\gets$ getHighestInfoGainP()
		\State question $\gets$ getHighestInfoQuestion(p)
		\State commAction $\gets$ self.ask(p, question)
		\ElsIf{action is defend}
		\State commAction $\gets$ self.claimRole()
		\EndIf
		
		\State updatePossibleWorlds(commAction)
		\EndFunction
	\end{algorithmic}\label{alg:communicate}
\end{algorithm}
\setcounter{algorithmcaption}{5}
\captionof{algorithmcaption}{High-level pseudocode of an agents turn during the 
communication sub-phase.}
It describes how an agents turn consists of finding their most plausible world, 
deciding what actions to take, choosing their target, as described above, and 
then updating their worlds' marks according to the outcome of the action.
The updating of their worlds is performed in accordance with algorithm 
\ref{alg:updatePossibleWorlds}, seen below. 
\begin{algorithm}[H]
	\caption{Update possible worlds}
	\begin{algorithmic}[1]
		\Function{updatePossWorlds}{information}
		\ForAll{p $in$ game.Ps}
		\ForAll{possWorld $in$ p.possWorlds}
		\State possWorld.UpdateMarks(information)
		\EndFor
		\EndFor
		\EndFunction
	\end{algorithmic}\label{alg:updatePossibleWorlds}
\end{algorithm}
\setcounter{algorithmcaption}{6}
\captionof{algorithmcaption}{The updating of possible worlds.}
Whenever an agent gets an answer for their communicative action, all agents add 
the answer to their world-views by updating their marks.\\

The phase ends when a variable amount of communicative actions have been 
performed by each agent, which, in this implementation has been arbitrarily set 
to 3. 

\subsubsection{Voting}\label{sec:voting}
When communication and the updating of possible-worlds has finished, the game
moves on to the voting phase. Each agent chooses who to vote for, in a very
similar manner to the choice of target for their communicative action 
previously shown in algorithm \ref{alg:GetHighInfoGainP}. They
chose the world with the least marks, i.e. the one they find to be the most
likely. If there are multiple, then they pick randomly between them. They then
select a random member of the mafia from that world, and then vote for that
agent.
 
\subsection{Night Phase}\label{sec:nightPhase}
The night phase is also broken down into two sub-phases: the night phase and 
the morning phase. 

\subsubsection{Night Phase - Nightly 
Actions}\label{sec:nightPhaseNightlyActions}
Nightly actions are performed during the actual night phase, and are tailored 
towards each role. For each role, we define their 
individual most likely world, $W$, as the world with the least amount of marks 
for them. \\
An example of how a nightly action is performed can be seen in algorithm 
\ref{alg:nightPhase}.
\begin{algorithm}[H]
	\caption{Night action}
	\begin{algorithmic}[1]
		\Function{performNightAction}{}
		\If{self.role == Sheriff}
		\State world $\gets$ getMostPlausibleWorld()
		
		\State susPs $\gets$ getSortedPossMafPs(world)
		\State susPs.remove(self.previousTargets)
		
		\State self.actResult $\gets$ interrogate(susPs[0])
		\EndIf
		\EndFunction
		
		\Statex
	\end{algorithmic}\label{alg:nightPhase}
\end{algorithm}
\setcounter{algorithmcaption}{7}
\captionof{algorithmcaption}{An example of a nightly action performed by the 
sheriff.}
The sheriff finds who the mafia members are in $W$, and then targets one of 
them, which he has not targeted before. Other players perform their actions 
similarly, such as the godfather trying to kill whomever is the sheriff in $W$. 
The doctor tries to save whomever is the sheriff in $W$, etc.
 
\subsubsection{Morning Phase}\label{sec:morningPhase}
Following the completing of all of the nightly actions, the morning phase 
begins. Its only purpose is to publicly announce the public effects of the 
nightly actions, and then make all agent update their world-views, by using the 
previously discussed algorithm \ref{alg:updatePossibleWorlds}.
As facts are revealed, possible-worlds are removed, meaning that one may slowly
infer the roles of other agents. Furthermore, as people die, marks are added or
altered based on how trustworthy the given victim's role was. \\
It is important to note, that while the semantics include inference in the form 
of propositions, and communicative actions can be expressed in the propositional
language, this is not included in our implementation. However, since we include
marks, and our decisions are based on these, we denote this as weak inference
of the communicative actions.


\subsection{Detailed run through}\label{sec:ARoundOfTheGame}
A round of our modelled game can be expressed in the dynamic inquiry language.
In a model defined as \cref{eq:3}, we let there be 10 agents \textbf{Ag} = \{a,
b, c, ..., j\}, where \textit{a} is a sheriff, \textit{b} is a godfather, and
the rest are villagers. This round is viewed from the sheriffs perspective, so
he does not know the roles of the other agents, only the amount of each role
that is in the game, i.e. 1 sheriff, 1 godfather, and 8 villagers. He then has
a set of propositions \{$\varphi$, $\psi$\, $\gamma$, ...\} where $\varphi$ =
"agent \textit{a} is a sheriff". $\psi$ = $(\psi_1 \lor \psi_2)$ = "agent
\textit{b} is a villager or godfather or ..." for all \textit{3} roles, except
sheriff, which agent \textit{a} knows he himself is. $\gamma$ = $(\gamma_1 \lor
	\gamma_2 \lor .. \lor \gamma_{n-1}) $ = "agent \textit{c} is a villager or
godfather or...", and so on for each agent. \\ In our simulation, we generate
$W$ by creating all possible worlds, based on the aforementioned propositions,
by utilizing the pseudocode function
\lstinline{generateWorlds()} provided in appendix \ref{app:B}. \\ A round then
starts with communicative actions, where agent \textit{b} says "I am villager",
represented for agent \textit{a} by $((p \land \neg q) \lor (\neg p \land q))$,
\todo{Expalin p and q} meaning that agent \textit{a} does not yet know whether
agent \textit{b}'s statement is true or false. But, by inference he may deduce
that if what agent \textit{b} says is correct, then it is also true that they
are the mentioned role. This is represented by $(p \land \neg q) \rightarrow
	\psi_1$ where $\psi_1$ is agent \textit{b} is a villager, and oppositely $(\neg
	p \land q) \rightarrow \neg \psi_1$ where $\neg \psi_1$ is agent \textit{b} is
not a villager. \\ Agent \textit{c} also says that they are a villager,
represented by $((g \land \neg h) \lor (\neg g \land h))$ in a similar manner.

When the agents communicate this, they choose which action to take, based on
what communicative action will result in the most amount of worlds being marked
as inactive, whenever the proposition provided by the communicative action is
proven or disproven \ref{alg:communicate}. This whole sequence can be expressed
by the following formula:

\begin{align}
	\begin{split}
		G = K_a(\varphi \land \psi \land\gamma)\land                        \\
		p \rightarrow \psi_1 \land \neg p \rightarrow \neg \psi_1 \land     \\
		q \rightarrow \gamma_1 \land \neg q \rightarrow \neg \gamma_1 \land \\
		((p \land \neg q) \lor (\neg p \land q)) \land                      \\
		((g \land \neg h) \lor (\neg g \land h))
		\label{eq:7}
	\end{split}
\end{align}

When the night phase comes, agent \textit{a} will interrogate agent \textit{b},
resulting in agent \textit{a} knowing the faction of agent \textit{b}. Agent
\textit{a} will come to know that agent \textit{b} is a member of the mafia.
Directly proving $\neg p$, since the role of a villager belongs to the town
faction, not the mafia faction. This action also excludes all active world from
the sheriff's knowledge, where agent \textit{b} is a member of the town,
leaving him only with world wherein he is a member of the mafia, which in this
case means he must be the godfather. During the same night, agent \textit{b}
targets, agent \textit{c}, killing him. The killing is then publicly announced
during the morning phase, along with the role of the victim. Recall from
\cref{eq:6}, we can say $\varphi_1!G\land\varphi_1$, which informally is that
everything before the public announcement, and the announcement itself, is now
applicable. As previously mentioned, this is performed by using algorithm 
\ref{alg:updatePossibleWorlds}, which simply iterates over all agents and all 
their respective worlds, and updates the information. Now recall back to 
\cref{eq:7}, after the newly
acquired information of both $\neg \psi_1$, the knowledge that agent \textit{b}
is not a villager, and $\gamma_2$, the role of agent \textit{c} we can now
simplify the previous expression, which results in:
\begin{align}
	G' = K_a(\varphi \land \neg \psi_1 \land \gamma_1) \land \neg p \land q
\end{align}
Furthermore, as agent \textit{a} began with the knowledge of agent \textit{b}
being either a godfather, or a villager, and they now know that they are not a
villager, they can infer that they must be a godfather, since that is the only
world that has not been excluded, based on the knowledge they gained during the
night. \\
The game then continues with a new communication phase, and the game goes on,
for a short while longer, until the godfather has been voted out.
