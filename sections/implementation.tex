\section{Implementation}\label{sec:implementation}
With the theory explained, we can now explore our implementation, which aims to
be as true to reality as possible, while being equivalent to the theory. At the
end of this section, we will go through an example round of our implementation,
but first, we will need to construct the foundation of it.
\subsection{The Knowledge of Agents}\label{TheKnowledgeOfAgents}
The knowledge and logical propositions of agents has been chosen to be
represented with a truth-table approach. Every agent has their own list of
possible-worlds, in which every single combination of agents and roles. This
means, that the more agents and roles there are, the longer this list becomes.
The following equation shows the space complexity of the list given agent count
$P$ and the number of agents with role $R$.
\begin{equation}
	W: P,R \in  \mathbb{N} \mapsto \frac{P!}{R!(P-R)!}\
\end{equation}

For each subsequent role that is added to the game, the space complexity
expands with:
\begin{equation}
	\begin{gathered}
		W: P, R_1, R_2\in  \mathbb{N} \mapsto \\
		\frac{P!\cdot(P-R_1)!}{R_1!\cdot(P-R_1)!\cdot
			R_2!\cdot(P-R_1-R_2)}\
		\footnote{If the number of agents equals the
			number of roles, then the formula collapses into P!.}
	\end{gathered}
\end{equation}
Each agent excludes possible-worlds that are not in
accordance with the role that they have been given.\\
For example: agent, \textit{a}, if given the role of sheriff, will exclude all
possible-worlds where their role is not sheriff, while another agent \textit{b} may
keep some of those possible-worlds, since they do not know the role of \textit{a}.\\
Furthermore, each possible-world also contains data on who have made what claims, and
whether that claim is true or false in this given possible-world. This is represented
by an array for each possible-world, which keeps track of the lies of agents. Going forward, these lies will be known as
\textit{marks}. If a world has many
marks, it implies that many agents have lied if this is the true world. It is
also important to remember, that we keep track of who contributed to each mark
in a given world. This will be explained further in the following sections.
\subsection{Updating Knowledge}\label{UpdatingKnowledge}
When a new fact is revealed, such as when an agent dies and their role is
revealed, all agents will immediately exclude all possible-worlds in which the
dead agent is anything other than their revealed role. This is essentially the
model update defined in \cref{eq:5}. An agent dying is the way that most roles
learn new facts.\\ Furthermore, depending on the role that died, all agents
update the marks that the dead agent contributed to. For example:\\ A sheriff
has a nightly action which allows them to gain more information than regular
villagers. Therefore, the marks that a sheriff has contributed to, should be
weighed more heavily than those of other roles. To emulate this other agents
add an additional mark, to any marks that were contributed to by the sheriff,
to further denote the importance of their opinions. \\ Conversely, should the
dead agent be revealed to be a member of the mafia, all agents will detract a
mark from the marks that the dead agent contributed to. Due to that the mafia
member may have tried to deceive the other agents
\subsection{Communicative Actions}\label{CommunicativeActions}
Communicative actions are the main way to contribute to marks in a given
possible-world. Let us assume that agent \textit{a} chooses the following
communicative action: "\textit{\ref{Com}. Claim to have a certain role.}" and
states, truthfully, "\textit{I am a Sheriff}". This will prompt all other
agents to add a mark to all possible-worlds in which \textit{a} is not a
sheriff. Recall from \cref{sem:5}, the world is only modelled if it is the
expected answer in the answering operator, based on the knowledge of the agent,
in that given world. The next agent then chooses a communicative action,
leading to a similar course of actions from the other agents. \todo{Fix this
	sentence} \\ The result of all agents communicating will be that agents have
added a significant amount of marks to their individual worlds. This means that
they will each now have some worlds which are more likely to be true than
others, since we assume that most people tell the truth, due to townspeople
having no incentive to lie. This ranking of worlds will be useful going
forward.\\ Almost all choices in the simulation is in some way related to the
amount of marks in their active worlds. The following pseudocode in
\cref{alg:GetHighInfoGainP,alg:GetNonAccused,alg:GetMostContradictory} relates
to how an agent chooses what communicative action to perform. .
\begin{algorithm}[H]
	\caption{GetHighInfoGainP(me, tWorlds)}
	\begin{algorithmic}
		\If{nonAccused.Count $>$ 0 OR Game.Round = 0}
		\State $(p, wID)$ $\gets$ GetNonAccused(me)
		\If{wID != -1}
		\State \Return (p, wID)
		\EndIf
		\EndIf

		\State (p, wID) $\gets$ GetMostContradictory(tWorlds, me)
		\If{wID != -1}
		\State \Return (p, wID)
		\EndIf

		\State w $\gets$ random world from me.PossWorlds
		\State p $\gets$ random player from w.PossPlayers
		\State \Return (p, index of w in me.PossWorlds)
		\label{alg:GetHighInfoGainP}
	\end{algorithmic}
\end{algorithm}
\vspace{-30px}
\setcounter{algorithmcaption}{0}
\captionof{algorithmcaption}{Get the highest information gain agent returns an agent based on different factors.
	At first, it prioritizes non accused agents as shown in \cref{alg:GetNonAccused}.
	Then find the most contradictory information as shown in \cref{alg:GetMostContradictory}.
	Otherwise, choose a random world and a random agent within.}
The selection of a target for these actions is based on maximizing the
potential information gain, \cref{alg:GetNonAccused}, identifying
agents who haven't yet been accused. Whereas
\cref{alg:GetMostContradictory} discovers agents with contradicting role claims.
This also emulates most of the functionality possible through the formal
semantics.
\begin{algorithm}[H]
	\caption{GetNonAccused(me)}
	\begin{algorithmic}
		\If{nonAccused.Count = 0 AND Game.Round = 0}
		\State nonAccused $\gets$ all players in me.PossWorlds[0]
		\EndIf

		\ForAll{accusation in me.nonAccu}
		\State me.nonAccu.Remove(accusation.Acusse)
		\EndFor

		\State me.nonAccu.Remove(me)

		\If{nonAccused.Count != 0}
		\State \Return nonAccused[randomI]
		\EndIf

		\State \Return (null, -1)
		\label{alg:GetNonAccused}
	\end{algorithmic}
\end{algorithm}
\vspace{-30px}
\setcounter{algorithmcaption}{1}
\captionof{algorithmcaption}{First round we append all agents to the non accused list and remove the agent itself from the list
	Then returning a random agent if the list is non-empty}

\begin{algorithm}[H]
	\caption{GetMostContradictory(tWorlds, me)}
	\begin{algorithmic}
		\State roleCounts $\gets$ getRoleCounts(tWorlds)

		\ForAll{w in tWorlds}
		\ForAll{p in w.PossPlayers where p != me AND p is alive}
		\State highest $\gets$ roleCounts[p].Max()
		\State secHighest $\gets$ roleCounts[p].SecondMax()

		\State contraScore $\gets$ secHighest / highest
		\If{contraScore $>$ maxScore}
		\State mostContradictory $\gets$ p
		\State maxScore $\gets$ contraScore
		\State wID $\gets$ index of w
		\EndIf
		\EndFor
		\EndFor
		\State \Return (mostContradictory, wID)
		\label{alg:GetMostContradictory}
	\end{algorithmic}
\end{algorithm}
\vspace{-5px}
\setcounter{algorithmcaption}{2}
\captionof{algorithmcaption}{Starting by storing a list of role counts for agents in the top 1\% of worlds.
	Iterating over the top 1\% of worlds and for each possible agent find their highest and second-highest role counts.
	Calculating a contradction score based on the 2 top role counts and checking if it's the highest contradiction score found.
	Returning the maxScore once all possible agents have been checked.
}

The choice of who to target is based on the belief that any proposition
regarding that agent will result in the most amount of worlds being marked as
inactive whenever it is proven or disproven.
\subsection{Voting}\label{Voting}
When communication and the addition of marks to worlds has finished, the game
moves on to the voting phase. Each agent chooses who to vote for, in a very
similar manner to the choice of target for their communicative action. They
chose the world with the least marks, i.e. the one they find to be the most
likely. If there are multiple, then they pick randomly between them. They then
select a random member of the mafia from that world, and then vote for that
person.
\subsection{Nightly Actions}\label{NightlyActions}
Nightly actions are tailored towards each role. For each role, we define their
most likely world, $W$, as the world with the least amount of marks. For
example: The godfather tries to kill whomever is the sheriff in $W$. The doctor
tries to save whomever is the sheriff in $W$. And the sheriff investigates a
random mafia member in $W$ that he has not targeted before.
\subsection{Weak Inference}\label{WeakInference}
As facts are revealed, possible-worlds are removed, meaning that one may slowly
infer the roles of other agents. Furthermore, as people die, marks are added or
altered based on how trustworthy the given victim's role was. \\It is important
to note, that while the semantics include inference in the form of
propositions, and communicative actions can be expressed in the propositional
language, this is not included in our implementation. However, since we include
marks, and our decisions are based on these, we denote this as weak inference
of the communicative actions.
\subsection{Detailed run through}\label{ARoundOfTheGame}
A round of our modelled game can be expressed in the dynamic inquiry language.
In a model defined as \cref{eq:3}, we let there be 10 agents \textbf{Ag} = \{a,
b, c, ..., j\}, where \textit{a} is a sheriff, \textit{b} is a godfather, and
the rest are villagers. This round is viewed from the sheriffs perspective, so
he does not know the roles of the other agents, only the amount of each role
that is in the game, i.e. 1 sheriff, 1 godfather, and 8 villagers. He then has
a set of propositions \{$\varphi$, $\psi$\, $\gamma$, ...\} where $\varphi$ =
"agent \textit{a} is a sheriff". $\psi$ = $(\psi_1 \lor \psi_2)$ = "agent
\textit{b} is a villager or godfather or ..." for all \textit{3} roles, except
sheriff, which agent \textit{a} knows he himself is. $\gamma$ = $(\gamma_1 \lor
	\gamma_2 \lor .. \lor \gamma_{n-1}) $ = "agent \textit{c} is a villager or
godfather or...", and so on for each agent. \\ In our simulation, we generate
$W$ by creating all possible worlds, based on the aforementioned propositions,
by utilizing the pseudocode function
\lstinline{generateWorlds()} provided in appendix \ref{app:B}. \\ A round then
starts with communicative actions, where agent \textit{b} says "I am villager",
represented for agent \textit{a} by $((p \land \neg q) \lor (\neg p \land q))$,
\todo{Expalin p and q} meaning that agent \textit{a} does not yet know whether
agent \textit{b}'s statement is true or false. But, by inference he may deduce
that if what agent \textit{b} says is correct, then it is also true that they
are the mentioned role. This is represented by $(p \land \neg q) \rightarrow
	\psi_1$ where $\psi_1$ is agent \textit{b} is a villager, and oppositely $(\neg
	p \land q) \rightarrow \neg \psi_1$ where $\neg \psi_1$ is agent \textit{b} is
not a villager. \\ Agent \textit{c} also says that they are a villager,
represented by $((g \land \neg h) \lor (\neg g \land h))$ in a similar manner.

\begin{algorithm}
	\caption{Communication}
	\begin{algorithmic}[1]
		\Function{communicate}{}
		\State world $\gets$ getMostPlausibleWorld()
		\State action $\gets$ self.getAction(world)

		\If{action is inquire or accuse}
		\State p $\gets$ getHighestInfoGainP()
		\State question $\gets$ getHighestInfoQuestion(p)
		\State commAction $\gets$ self.ask(p, question)
		\ElsIf{action is defend}
		\State commAction $\gets$ self.claimRole()
		\EndIf

		\State updatePossibleWorlds(commAction)
		\EndFunction
	\end{algorithmic}
\end{algorithm}\label{alg:communicate}

When the agents communicate this, they choose which action to take, based on
what communicative action will result in the most amount of worlds being marked
as inactive, whenever the proposition provided by the communicative action is
proven or disproven \ref{alg:communicate}. This whole sequence can be expressed
by the following formula:

\begin{align}
	\begin{split}
		G = K_a(\varphi \land \psi \land\gamma)\land                        \\
		p \rightarrow \psi_1 \land \neg p \rightarrow \neg \psi_1 \land     \\
		q \rightarrow \gamma_1 \land \neg q \rightarrow \neg \gamma_1 \land \\
		((p \land \neg q) \lor (\neg p \land q)) \land                      \\
		((g \land \neg h) \lor (\neg g \land h))
		\label{eq:7}
	\end{split}
\end{align}

When the night phase comes, agent \textit{a} will interrogate agent \textit{b},
resulting in agent \textit{a} knowing the faction of agent \textit{b}. Agent
\textit{a} will come to know that agent \textit{b} is a member of the mafia.
Directly proving $\neg p$, since the role of a villager belongs to the town
faction, not the mafia faction. This action also excludes all active world from
the sheriff's knowledge, where agent \textit{b} is a member of the town,
leaving him only with world wherein he is a member of the mafia, which in this
case means he must be the godfather. During the same night, agent \textit{b}
targets, agent \textit{c}, killing him. The killing is then publicly announced
during the morning phase, along with the role of the victim. Recall from
\cref{eq:6}, we can say $\varphi_1!G\land\varphi_1$, which informally is that
everything before the public announcement, and the announcement itself, is now
applicable. In our simulation, this is done by calling
\lstinline[]{updatePossibleWorlds(information)}, displayed in
\cref{lst:updateWorld}

\begin{algorithm}[h]
	\caption{Snippet from appendix C \label{lst:updateWorld}}
	\begin{algorithmic}[1]
		\Function{updatePossWorlds}{information}
		\ForAll{p $in$ game.Ps}
		\ForAll{possWorld $in$ p.possWorlds}
		\State possWorld.UpdateMarks(information)
		\EndFor
		\EndFor
		\EndFunction
	\end{algorithmic}
\end{algorithm}

Which simply iterates over all agents and all their respective worlds, and
updates the information. Now recall back to \cref{eq:7}, after the newly
acquired information of both $\neg \psi_1$, the knowledge that agent \textit{b}
is not a villager, and $\gamma_2$, the role of agent \textit{c} we can now
simplify the previous expression, which results in:
\begin{align}
	G' = K_a(\varphi \land \neg \psi_1 \land \gamma_1) \land \neg p \land q
\end{align}
Furthermore, as agent \textit{a} began with the knowledge of agent \textit{b}
being either a godfather, or a villager, and they now know that they are not a
villager, they can infer that they must be a godfather, since that is the only
world that has not been excluded, based on the knowledge they gained during the
night. \\
The game then continues with a new communication phase, and the game goes on,
for a short while longer, until the godfather has been voted out.
