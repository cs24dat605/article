\section{Implementation}\label{sec:implementation}
With the theory explained, we can now explore our implementation, which aims to
be as true to our formal description as possible. We will start by laying the
foundation of the most pivotal data structures, followed by a walk-through of
the implementation of each phase of the game.

\subsection{Foundational Data Structures}\label{sec:foundationalDataStructures}
To provide some context for the upcoming sections, we will first describe the
data structures they are based upon.

A game consists of some $n$ number of agents, wherein each agent has $m$ amount
of worlds, where $m$ is the result of \cref{eq:numofworlds}. A world, often
referred to as a possible world, describes a possible combination of
roles/agents. Each world has a list of roles, which represents that specific
world's combination. This relation is depicted in \cref{fig:DataStructuresUML}.
\begin{comment}
To provide some context for the upcoming sections, this part will describe the
data structures they are based upon. \\ \\ A world, often
referred to as a possible world, describes a possible combination of roles/agents.
Most information is unknown to an agent in its environment,
therefore if a role of another agent is unknown they could be all roles. So for
each agent, they store their own list of all possible worlds, with every single
combination of agents and roles. Each world object itself stores whether it is active,
and number of marks. Marks and is active\footnote{Is active refers to active and inactive
	worlds} both being previously described in \cref{sec:Modelling}.\\ The
player object stores information about the agent, such as name, role, and alive
status. Besides storing information it acts as a gateway to functions that
include the agent. Such as communication, instead of calling a function and
including the agent, the communication is called directly from the agent object. \\
The overall data structure is the game object, that encapsulates all
information and objects into a single object.
\end{comment}
\renewcommand{\umlfillcolor}{white}
\renewcommand{\umldrawcolor}{blue}
\begin{figure}[H]
	\centering
	\scalebox{0.8}{
		\begin{tikzpicture}
			\begin{class}[text width= 2.5cm]{Game}{0,0}
				\attribute{agents : List}
				\operation{runDayPhase()}
				\operation{runNightPhase()}
				\operation{checkFinished()}
			\end{class}
			\begin{class}[text width=4.5cm]{Agent}{5,1.2}
				\attribute{worlds : list}
				\operation{updateWorlds(information)}
				\operation{nightAction()}
				\operation{communication()}
			\end{class}
			\begin{class}[text width=4cm]{World}{3,-3}
				\attribute{possibleAgents: list}
				\attribute{marks : integer}
				\attribute{isActive : boolean}
				\attribute{isPrivateActive : boolean}
			\end{class}
			\unidirectionalAssociation{Game}{1..*}{}{Agent}{}{}
			\unidirectionalAssociation{Agent}{1..*}{}{World}{}{}
		\end{tikzpicture}}
	\vspace*{3mm}
	\caption{Simplified UML diagram of data structures}
	\label{fig:DataStructuresUML}
\end{figure}
We argue this encapsulates the model both described in \cref{sec:Modelling}, and the formalisation in
\cref{sec:DynamicInquiryLanguage}, \cref{eq:3}, most noteworthy is the relation between $W$ and \textbf{Ag}.
\subsubsection{The Knowledge of Agents}\label{sec:TheKnowledgeOfAgents}
The knowledge and logical propositions of agents has been chosen to be
represented with a truth-table approach. Which refers to the possible worlds
which store every single combination of agents and roles. The following
equation shows the space complexity of the list given agent count $P$ and the
number of agents with role $R$.
\begin{equation}
	W: P,R \in  \mathbb{N} \mapsto \frac{P!}{R!(P-R)!}\
\end{equation}

For each subsequent role, $R_1, R_2, .., R_n$ that is added, the complexity expands
with:
\begin{equation}
	\begin{gathered}
		W: P, R_1, R_2, n\in  \mathbb{N} \mapsto \\
		\frac{P!(P-R_1)}{\prod\limits_{i=1}^{n}R_i-1(P+\sum\limits_{j=1}^{i})}
		\footnote{If the number of agents equals the
			number of roles, then the formula collapses into P!.}
		\label{eq:numofworlds}
	\end{gathered}
\end{equation}
Each agent excludes possible-worlds that are not in
accordance with the role that they have been given.\\
For example: agent, \textit{a}, if given the role of sheriff, will exclude all
possible-worlds where their role is not sheriff, while another agent \textit{b}
may
keep some of those possible-worlds, since they do not know the role of
\textit{a}.\\ In our implementation, this means that for agent \textit{a} the worlds, 
where they are not a sheriff are privately inactive.
Furthermore, each possible-world also contains data on who have made what
claims, and
whether that claim is true or false in this given possible-world. This is
represented
by an array for each possible-world, which keeps track of the lies of agents.
Going forward, these lies will be known as
\textit{marks}. If a world has many
marks, it implies that many agents have lied if this is the true world. It is
also important to remember, that we keep track of who contributed to each mark
in a given world. This will be explained further in the following sections.

\subsection{Updating Knowledge}\label{sec:UpdatingKnowledge}
When a new fact is revealed, such as when an agent dies and their role is
revealed, all agents will immediately exclude all possible-worlds in which the
dead agent is anything other than their revealed role. Implementation wise, this means
that the worlds which are not in accordance with the new information are set as inactive. We will henceforth refer to these as active or inactive worlds. 
This is corresponds to the model update defined in \cref{eq:5}. An agent dying is the way that most roles learn new facts. \\ Furthermore, depending on the role that died, all agents
update the marks that the dead agent contributed to. For example:\\ A sheriff
has a nightly action which allows them to gain more information than regular
villagers. Therefore, the marks that a sheriff has contributed to, should be
weighed more heavily than those of other roles. To emulate this other agents
add an additional mark, to any marks that were contributed to by the sheriff,
to further denote the importance of their opinions. \\ Conversely, should the
dead agent be revealed to be a member of the mafia, all agents will detract a
mark from the marks that the dead agent contributed to. Due to that the mafia
member may have tried to deceive the other agents

\subsection{Beginning of the Game}\label{sec:beginningOfTheGame}
With the foundational data structures explained, we can begin the game, which
is done in accordance with the pseudocode in \cref{alg:StartGame}.
\begin{algorithm}[H]
	\caption{StartGame}
	\begin{algorithmic}[1]
		\Function{StartGame}{}
		\State loadGameConfiguration()
		\State generateWorlds()

		\While{!gameFinished}
		\State dayPhase()
		\State nightPhase()
		\State checkFinished()
		\EndWhile
		\EndFunction
	\end{algorithmic}\label{alg:StartGame}
\end{algorithm}
\setcounter{algorithmcaption}{0}
\captionof{algorithmcaption}{Pseudocode for starting and running the
	game.}
The game begins by loading the role-configuration for that specific game, and
then generating the worlds for all players. It then goes through the day- and
night phases, followed by checking if either team has won. It does this in a
loop until either team has won.

\subsection{Day Phase}\label{sec:dayPhase}
The day phase is split into two sub-phases: communication and voting. These
phases are performed in order, and controlled by \cref{alg:dayPhase}.
\begin{algorithm}[H]
	\caption{Day phase}
	\begin{algorithmic}[1]
		\Function{dayPhase}{}
		\ForAll{p $in$ game.Ps}
		\State p.communicate()
		\EndFor
		\ForAll{p $in$ game.Ps}
		\State votes $\gets$ votes + voting()
		\EndFor

		\State killMostVoted(votes)
		\EndFunction
	\end{algorithmic}\label{alg:dayPhase}
\end{algorithm}
\setcounter{algorithmcaption}{1}
\captionof{algorithmcaption}{The order of sub-phases within the day phase.}
First all players communicate, then they all vote.

\subsubsection{Communication}\label{sec:communication}
The communication sub-phase is where agents share information with each other
based on the marks in their active worlds. Communicative actions are
the main way to contribute to marks in a given possible-world. The way that a
given agent chooses who to target with their communicative action is chosen in
accordance with \cref{alg:GetHighInfoGainP}.
\begin{algorithm}[H]
	\caption{GetHighInfoGainP(me, tWorlds)}
	\begin{algorithmic}
		\If{nonAccused.Count $>$ 0 OR Game.Round = 0}
		\State $(p, wID)$ $\gets$ GetNonAccused(me)
		\If{wID != -1}
		\State \Return (p, wID)
		\EndIf
		\EndIf

		\State (p, wID) $\gets$ GetMostContradictory(tWorlds, me)
		\If{wID != -1}
		\State \Return (p, wID)
		\EndIf

		\State w $\gets$ random world from me.PossWorlds \State
		p $\gets$ random player from w.PossPlayers \State \Return (p, index of w in
		me.PossWorlds)
	\end{algorithmic}\label{alg:GetHighInfoGainP}
\end{algorithm}
\setcounter{algorithmcaption}{2}
\captionof{algorithmcaption}{The base algorithms that handles the communicative logic.}
Where the parameter "me" refers to the agent deciding an action. To get the highest information gain, \cref{alg:GetHighInfoGainP} returns an
agent based on different factors.
First it prioritizes non accused agents as shown in
\cref{alg:GetNonAccused}.
Then finds the most contradictory information as shown in
\cref{alg:GetMostContradictory}. \\
\begin{algorithm}[H]
	\caption{GetNonAccused(me)}
	\begin{algorithmic}
		\If{nonAccused.Count = 0 AND Game.Round = 0}
		\State nonAccused $\gets$ all players in me.PossWorlds[0]
		\EndIf

		\ForAll{accusation in me.accusations}
		\State nonAccu.Remove(accusation.Acusse)
		\EndFor

		\State nonAccu.Remove(me)

		\If{nonAccused.Count != 0}
		\State \Return nonAccused[randomI]
		\EndIf

		\State \Return (null, -1)
	\end{algorithmic}\label{alg:GetNonAccused}
\end{algorithm}
\setcounter{algorithmcaption}{3}
\captionof{algorithmcaption}{Returns an agent that haven't been accused yet}
Each agent initialises a list of all other agents at the
start of the first communication phase. Whenever an agent targets another agent
with a communicative action, they remove the target agent from their individual
list. When an agent has targeted all other agents with one communicative action
they will have gained some knowledge of all agents, which they may use to determine
the new best target for their communicative
actions. This is done in the next step of \cref{alg:GetHighInfoGainP},
by invoking \cref{alg:GetMostContradictory}.
\begin{algorithm}[H]
	\caption{GetMostContradictory(tWorlds, me)}
	\begin{algorithmic}
		\State roleCounts $\gets$ getRoleCounts(tWorlds)

		\ForAll{w in tWorlds}
		\ForAll{p in w.PossPlayers where p != me AND p is alive}
		\State highest $\gets$ roleCounts[p].Max()
		\State secHighest $\gets$ roleCounts[p].SecondMax()

		\State contraScore $\gets$ secHighest / highest
		\If{contraScore $>$ maxScore}
		\State mostContradictory $\gets$ p
		\State maxScore $\gets$ contraScore
		\State wID $\gets$ index of w
		\EndIf
		\EndFor
		\EndFor
		\State \Return (mostContradictory, wID)
	\end{algorithmic}\label{alg:GetMostContradictory}
\end{algorithm}
\setcounter{algorithmcaption}{4}
\captionof{algorithmcaption}{Returns an agent with the most conflicting role claims. Self refers to an instance of an Agent.}
This algorithm outputs the agent which is the most suspicious due to being
suspected of being the highest difference of roles in the top 1\% of active possible-worlds.\\
This whole process is simply described in the following high-level algorithm
\ref{alg:communicate} for how one agent handles their turn in the communication
sub-phase.
\begin{algorithm}[H]
	\caption{Communication}
	\begin{algorithmic}[1]
		\Function{communicate}{}
		\State world $\gets$ getMostPlausibleWorld()
		\State action $\gets$ self.getAction(world)

		\If{action is inquire or accuse}
		\State p $\gets$ getHighestInfoGainP()
		\State question $\gets$ getHighestInfoQuestion(p)
		\State commAction $\gets$ self.ask(p, question)
		\ElsIf{action is defend}
		\State commAction $\gets$ self.claimRole()
		\EndIf

		\State updatePossibleWorlds(commAction)
		\EndFunction
	\end{algorithmic}\label{alg:communicate}
\end{algorithm}
\setcounter{algorithmcaption}{5}
\captionof{algorithmcaption}{High-level pseudocode of an agents turn during the
	communication sub-phase. Self refers to an instance of an Agent class.}
It describes how an agents turn consists of finding their most plausible world,
deciding what actions to take, choosing their target, as described above, and
then updating their worlds' marks according to the outcome of the action.
The updating of their worlds is performed in accordance with
\cref{alg:updatePossibleWorlds}, seen below.
\begin{algorithm}[H]
	\caption{Update possible worlds}
	\begin{algorithmic}[1]
		\Function{updatePossWorlds}{information}
		\ForAll{p $in$ game.Ps}
		\ForAll{possWorld $in$ p.possWorlds}
		\State possWorld.UpdateMarks(information)
		\EndFor
		\EndFor
		\EndFunction
	\end{algorithmic}\label{alg:updatePossibleWorlds}
\end{algorithm}
\setcounter{algorithmcaption}{6}
\captionof{algorithmcaption}{The updating of possible worlds.}
Whenever an agent gets an answer for their communicative action, all agents update their
world view by invoking \cref{alg:updatePossibleWorlds}.\\

The phase ends when a variable amount of communicative actions have been
performed by each agent, which, in this implementation has been arbitrarily set
to 3.

\subsubsection{Voting}\label{sec:voting}
When communication and the updating of possible-worlds has finished, the game
moves on to the voting phase. Each agent chooses who to vote for, in a very
similar manner to the choice of target for their communicative action
previously shown in \cref{alg:GetHighInfoGainP}. They chose the active world with the
least marks, i.e. the one they find to be the most likely. If there are
multiple, then they pick randomly between them. They then select a random
member of the mafia from that world, and then vote for that agent.

\subsection{Night Phase}\label{sec:nightPhase}
The night phase is also broken down into two sub-phases: the night phase and
the morning phase.

\subsubsection{Night Phase - Nightly
	Actions}\label{sec:nightPhaseNightlyActions}
Nightly actions are performed during the night phase, and are tailored towards
each role. For each role, we define their individual most likely world, $W$, as
the world with the least amount of marks for them. \\ An example of how a
nightly action is performed can be seen in \cref{alg:nightPhase}.
\begin{algorithm}[H]
	\caption{Night action}
	\begin{algorithmic}[1]
		\Function{performNightAction}{}
		\If{self.role == Sheriff}
		\State world $\gets$ getMostPlausibleWorld()

		\State susPs $\gets$ getSortedPossMafPs(world)
		\State susPs.remove(self.previousTargets)

		\State self.actResult $\gets$ interrogate(susPs[0])
		\EndIf
		\EndFunction

		\Statex
	\end{algorithmic}\label{alg:nightPhase}
\end{algorithm}
\setcounter{algorithmcaption}{7}
\captionof{algorithmcaption}{An example of a nightly action performed by the
	sheriff. Self refers to an instance of an Agent.}
The sheriff finds who the mafia members are in $W$, and then targets one of
them, which he has not targeted before. Other players perform their actions
similarly, such as the godfather trying to kill whomever is the sheriff in $W$.
The doctor tries to save whomever is the sheriff in $W$, etc.

\subsubsection{Morning Phase}\label{sec:morningPhase}
In the real life version of the game, the morning phase begins after the night
phase. Its only purpose is to publicly announce the public effects of the
nightly actions, and then make all agent update their world-views, by using the
previously discussed \cref{alg:updatePossibleWorlds}. However in the
implementation facts are aquired as soon as an action has occured. This
change does not affect the game, as all agents already have declared which
night action they want to take.\\ 
As facts are revealed, possible-worlds are
de-activated, meaning that one may slowly infer the roles of other agents.
Furthermore, as people die, marks are added or altered based on how trustworthy
the given victim's role was. \\ It is important to note, that while the
semantics include inference in the form of propositions, and communicative
actions can be expressed in the propositional language, this is not included in
our implementation. However, since we include marks, and our decisions are
based on these, we denote this as weak inference of the communicative actions.

\subsection{Detailed run through}\label{sec:ARoundOfTheGame}
A round of our modelled game can be expressed in the dynamic inquiry language.
In a model defined as \cref{eq:3}, we let there be 10 agents \textbf{Ag} = \{a,
b, c, ..., j\}, where \textit{a} is a sheriff, \textit{b} is a godfather, and
the rest are villagers. This round is viewed from the sheriffs perspective, so
he does not know the roles of the other agents, only the amount of each role
that is in the game, i.e. 1 sheriff, 1 godfather, and 8 villagers. He then has
a set of propositions \{$\varphi$, $\psi$\, $\gamma$, ...\} where $\varphi$ =
"agent \textit{a} is a sheriff". $\psi$ = $(\psi_1 \lor \psi_2)$ = "agent
\textit{b} is a villager or godfather or ..." for all \textit{3} roles, except
sheriff, which agent \textit{a} knows he himself is. $\gamma$ = $(\gamma_1 \lor
	\gamma_2 \lor .. \lor \gamma_{n-1}) $ = "agent \textit{c} is a villager or
godfather or...", and so on for each agent. \\ In our simulation, we generate
$W$ by creating all possible worlds, based on the aforementioned propositions,
by utilizing the pseudocode function
\lstinline{generateWorlds()} provided in appendix \ref{app:B}. \\ A round then
starts with communicative actions, where agent \textit{b} says "I am villager",
represented for agent \textit{a} by $((p \land \neg q) \lor (\neg p \land q))$, where p is "agent \textit{b} is a villager and is telling the truth",
and q is "agent b is not a villager and is lying". The expression essentielly represents that agent \textit{a} does not yet know whether
agent \textit{b}'s statement is true or false. But, by inference he may deduce
that if what agent \textit{b} says is correct, then it is also true that they
are the mentioned role. This is represented by $(p \land \neg q) \rightarrow
	\psi_1$ where $\psi_1$ is agent \textit{b} is a villager, and oppositely $(\neg
	p \land q) \rightarrow \neg \psi_1$ where $\neg \psi_1$ is agent \textit{b} is
not a villager. \\ Agent \textit{c} also says that they are a villager,
represented by $((g \land \neg h) \lor (\neg g \land h))$ in a similar manner.

When the agents communicate this, they choose which action to take, based on
what communicative action will result in the most amount of worlds being marked
as inactive, whenever the proposition provided by the communicative action is
proven or disproven \ref{alg:communicate}. This whole sequence can be expressed
by the following formula:

\begin{align}
	\begin{split}
		G = K_a(\varphi \land \psi \land\gamma)\land                        \\
		p \rightarrow \psi_1 \land \neg p \rightarrow \neg \psi_1 \land     \\
		q \rightarrow \gamma_1 \land \neg q \rightarrow \neg \gamma_1 \land \\
		((p \land \neg q) \lor (\neg p \land q)) \land                      \\
		((g \land \neg h) \lor (\neg g \land h))
		\label{eq:7}
	\end{split}
\end{align}

When the night phase comes, agent \textit{a} will interrogate agent \textit{b},
resulting in agent \textit{a} knowing the faction of agent \textit{b}. Agent
\textit{a} will come to know that agent \textit{b} is a member of the mafia.
Directly proving $\neg p$, since the role of a villager belongs to the town
faction, not the mafia faction. This action also excludes all active world from
the sheriff's knowledge, where agent \textit{b} is a member of the town,
leaving him only with world wherein he is a member of the mafia, which in this
case means he must be the godfather. During the same night, agent \textit{b}
targets, agent \textit{c}, killing him. The killing is then publicly announced
during the morning phase, along with the role of the victim. Recall from
\cref{eq:6}, we can say $\varphi_1!G\land\varphi_1$, which informally is that
everything before the public announcement, and the announcement itself, is now
applicable. As previously mentioned, this is performed by using algorithm
\ref{alg:updatePossibleWorlds}, which iterates over all agents and all their
respective worlds, and updates the information. Now recall back to \cref{eq:7},
after the newly acquired information of both $\neg \psi_1$, the knowledge that
agent \textit{b} is not a villager, and $\gamma_2$, the role of agent
\textit{c} we can now simplify the previous expression, which results in:
\begin{align}
	G' = K_a(\varphi \land \neg \psi_1 \land \gamma_1) \land \neg p \land q
\end{align}
Furthermore, as agent \textit{a} began with the knowledge of agent \textit{b}
being either a godfather, or a villager, and they now know that they are not a
villager, they can infer that they must be a godfather, since that is the only
world that has not been excluded, based on the knowledge they gained during the
night. \\
The game then continues with a new communication phase, and the game goes on,
for a short while longer, until the godfather has been voted out.
